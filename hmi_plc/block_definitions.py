"""
Block definitions for HMI system simulations.
Maps FB/UDT structures to I/O tables for block view.
Can be loaded from JSON (generated by scl_parser from .scl files).
"""
import json
import os
from typing import Dict, Optional

# FB_MPTS from MultiPlatFunctions/MPTS/Siemens (manual fallback)
MPTS_BLOCK = {
    "name": "FB_MPTS",
    "title": "MPTS",
    "inputs": [
        ("Cmd.Run", "Bool", "Run (Charge+Discharge)"),
        ("Cmd.Charge", "Bool", "Charge"),
        ("Cmd.Discharge", "Bool", "Discharge"),
        ("Cmd.Venting", "Bool", "Venting"),
        ("Cmd.Unclogging", "Bool", "Unclogging"),
        ("Cmd.LeakTest", "Bool", "Leak test"),
        ("E_Stop", "Bool", "Emergency stop"),
        ("Alarm", "Bool", "Alarm"),
        ("HeadInPosition", "Bool", "Head in position"),
        ("iChamberPressure", "Real", "Chamber pressure [bar]"),
        ("iInletValvePressure", "Real", "Inlet valve pressure [bar]"),
        ("iOutletValvePressure", "Real", "Outlet valve pressure [bar]"),
    ],
    "outputs": [
        ("St.Busy", "Bool", "Busy"),
        ("St.Charged", "Bool", "Charged"),
        ("St.Discharged", "Bool", "Discharged"),
        ("St.Done", "Bool", "Done"),
        ("St.Error", "Bool", "Error"),
        ("St.Mode", "Int", "Mode (0=Idle,1=Charging,2=Manual,3=Discharging,4=Unclogging,5=Venting,6=Cleaning,7=LeakTesting)"),
        ("oInletValvePR", "Real", "Inlet valve setpoint [bar]"),
        ("oOutletValvePR", "Real", "Outlet valve setpoint [bar]"),
        ("oChamberValvePR", "Real", "Chamber valve setpoint [bar]"),
        ("oChamberValveOn", "Bool", "Chamber valve ON"),
        ("oVibratorOn", "Bool", "Vibrator ON"),
        ("oFullRedValveOn", "Bool", "Full/Red vacuum valve"),
        ("oChamberVacuumValveOn", "Bool", "Chamber vacuum valve"),
        ("iCurrentStep", "Int", "Current step"),
    ],
}

# Mode labels for display
MPTS_MODE_LABELS = {
    0: "Idle",
    1: "Charging",
    2: "Manual",
    3: "Discharging",
    4: "Unclogging",
    5: "Venting",
    6: "Cleaning",
    7: "LeakTesting",
}

BLOCK_REGISTRY = {
    "mpts": MPTS_BLOCK,
    "FB_MPTS": MPTS_BLOCK,
}


def load_block_from_json(path: str) -> Optional[Dict]:
    """Load block definition from JSON file (output of scl_parser)."""
    if not path or not os.path.isfile(path):
        return None
    try:
        with open(path, "r", encoding="utf-8") as f:
            data = json.load(f)
        return _normalize_block(data)
    except Exception:
        return None


def _normalize_block(data: Dict) -> Dict:
    """Ensure block has inputs, outputs, in_out with direction."""
    def ensure_direction(items, default):
        for item in items:
            if isinstance(item, dict) and "direction" not in item:
                item["direction"] = default
    def to_dict_list(items):
        result = []
        for x in items:
            if isinstance(x, dict):
                result.append(x)
            elif isinstance(x, (list, tuple)):
                result.append({"name": x[0], "type": x[1] if len(x) > 1 else "Bool", "desc": x[2] if len(x) > 2 else ""})
            else:
                result.append({"name": str(x), "type": "Bool", "desc": ""})
        return result
    data["inputs"] = to_dict_list(data.get("inputs", []))
    data["outputs"] = to_dict_list(data.get("outputs", []))
    data["in_out"] = to_dict_list(data.get("in_out", []))
    ensure_direction(data["inputs"], "request")
    ensure_direction(data["outputs"], "status")
    ensure_direction(data["in_out"], "status")
    return data


def register_block_from_json(path: str, key: Optional[str] = None) -> bool:
    """Load JSON and register in BLOCK_REGISTRY. Returns True if ok."""
    block = load_block_from_json(path)
    if not block:
        return False
    k = key or block.get("name", "block")
    BLOCK_REGISTRY[k] = block
    BLOCK_REGISTRY[block.get("name", k)] = block
    return True
